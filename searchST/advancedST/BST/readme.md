#二叉查找树  
定义：是一颗二叉树，其中每个结点都含有一个comparable的键，且每个结点的键都大于其在左子树中的任意结点的键，而小于在右子树的任意结点的键  

1. 查找
如果树是空的则查找未命中，如果被查找的键和根结点的键相等，查找命中，否则我们就(递归地)在适当的子树种继续查找，被查找的键较小就选择左子树，较大则选择右子树。  


2. 插入  
如果树是空的，就返回一个含有该键值对的新结点，如果被查找的键小于根结点的键，我们会继续在左子树中插入该键，否则在右子树中插入该键  

递归：
对于get()方法，这对应着一系列的返回指令(return)
对于put()方法，意味着重置搜索路径上每个父结点指向子结点的链接，并增加路径上每个结点中的计数器的值（`x.N = size(x.left) + size(x.right) + 1;`）  

####3.   有序性相关的方法与删除操作  
(1)  最大键和最小键(min()和max())  
        如果根结点的左链接为空，那么一颗二叉查找树中最小的键就是根结点，如果左链接非空，那么树中的最小键就是左子树的最小键。  
(2) 向上取整和向下取整(floor())  
如果给定的键key小于二叉查找树的根结点的键，那么小于等于key的最大键(floor)一定在根结点的左子树种，如果给定的键key大于二叉查找树的根结点，那么只有当根结点右子树种存在小于等于key的结点时，小于等于key的最大键才会出现在右子树种，否则根结点就是小于等于key的最大值  
(3) 选择操作(select()) &nbsp;&nbsp; 找到排名为k的键  
    如果左子树的结点数t大于k,那我们(递归地)在左子树中查找排名为k的键，如果t等于k,我们就返回根结点中的键,如果t等于t,我们就返回根结点中的键，如果t小于k，我们(递归)在右子树中查找排名为(k-t-1)的键。  
(4) 排名(rank()方法)  &nbsp;&nbsp;返回给定键的排名  
如果给定的键和根结点的键相等，我们返回左子树种的结点总数t，如果给定的键小于根结点，我们会返回该键在左子树中的排名(递归计算)，如果给定的键大于根结点，我们会返回t+1(根结点)加上它在右子树中的排名。  

4. 删除操作  
(1)删除最大键和删除最小键  
(2)删除操作  

5. 范围查找  
将所有落在给范围内的键加入一个队列Queue，并跳过那些不可能会有所查键的子树  
为了在指定范围之内的键加入队列，递归的查找根节点的左子树，然后查找根结点，然后(递归)查找根结点的右子树。

性能比较  
<table>
    <tr>
        <th rowspan="2">算法</th>
        <th colspan="2">最坏的成本</th>
        <th colspan="2">平均情况下的成本</th>
        <th rowspan="2">是否支持有序性相关的操作</th>
    </tr>
    <tr>
        <th>查找</th>
        <th>插入</th>
        <th>查找</th>
        <th>插入</th>
    </tr>
    <tr>
        <th>顺序查找(无序链表)</th>
        <th>N</th>
        <th>N</th>
        <th>N/2</th>
        <th>N</th>
        <th>否</th>
    </tr>
        <tr>
        <th>二分查找(有序数组)</th>
        <th>lgN</th>
        <th>2N</th>
        <th>lgN</th>
        <th>N</th>
        <th>是</th>
    </tr>
    <tr>
        <th>二叉树查找(二叉树查找)</th>
        <th>N</th>
        <th>N</th>
        <th>1.39lgN</th>
        <th>1.39N</th>
        <th>是</th>
    </tr>
</table> 

确定:最坏的情况出现，当用例将所有键按照顺序或者逆序插入符号表就会增加这种情况出现的概率  

所以为了避免这种情况，寻找更好的算法和数据结构---平衡查找树





