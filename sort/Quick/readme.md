#快速排序  

归并排序和快速排序都是分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序，快速排序和归并排序是互补的:归并将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就是自然有序的。

就像理解归并排序的核心是merge(),理解快速排序的核心是partition().  

partition()切分:最后形成的结果  
1.  对于某个j,a[j]已经排序。   
2.  a[lo]到a[j-1]中的所有元素都不大于a[j]   
3.  a[j]到a[hi]中的所有元素都不小于a[j]  
  
思路:取a[lo]作为切分元素,一般是第一个元素，然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素，并交换他们的位置，如此继续，到指针相遇时，我们只需要将切分元素a[lo]和左子数组最右侧的元素交换然后返回j即可。  
```
		Comparable v = a[lo];  //切分元素
		while(true){
			//扫描左右，检查扫描是否结束并交换元素
			while(less(a[++i],v)) if(i == hi) break;
			while(less(v,a[--j])) if(j == lo) break;
			if(i >= j) break;
			exch(a,i,j);
		}
		exch(a,lo,j);  //将v=a[j	]放入正确的位置
		return j;    //a[lo...j-1]<=a[j]<=a[j+1...hi]达成
```  

每一次递归完成就会使a[j]是有序的。  

然后再来理解sort()方法：  
```
		if(hi <= lo) return;
		int j = partition(a,lo,hi);//切分
		sort(a,lo,j-1); //将左半部分a[lo...j-1]排序
		sort(a,j+1,hi); //将右半部份a[j+1...hi]排序
```
先进行切分,然后递归，对左半边进行排序，然后对右半边进行排序，从上到下，每一次，都会使一个数a[j]有序，直到最底层，只有一个数的时候。  

缺点：在切分不平衡时可能会极为低效，如果第一次从最小的元素切分，第二次从第二小的元素切分，如此这般，每次调用移除一个元素，导致大数组需要切分很多次， 所以要在快速排序前将数组随机排序。  

算法改进  
切换到插入排序  
1.  对于小数组，快速排序比插入排序慢  
2.  因为递归，快速排序的sort方法在小数组也会调用自己  
方法 if(hi <= lo + M) {Insertion.sort(a,lo,hi);return} M在5~15之间
