#优先队列  
要解决的问题是:如果数据是无限输入的情况下，每次取最大或最小值，怎么办?  
也许说可以每次输入一个值就排序，但是代价太大，性能损失大。这里的关键是如何解决插入元素和删除最大元素的性能问题，所以就用到了基于堆的排序。  

另外，实现栈或是队列与实现优先队列的最大不同在于对性能的要求。  

定义：
先理解堆有序
堆有序:一颗二叉树的每个结点，都大于等于他的两个子节点。  

然后是二叉堆  
二叉堆:是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存(不使用数组的第一个位置),直白点，就是数据在数组的存储方式。  
特点:  也是关键点，是理解sink和swim方法的重点
1. 位置为k的结点的父节点的位置为k/2
2. 两个子节点的位置分别为2k和2k+1  

队列中的核心方法是swin()方法和sink()方法  
swin()上浮:结点比它的父节点更大，那就通过交换它和它的父节点来修复堆  
sink()下沉:结点比它的子节点或是其中之一小，那么可以通过将它和它的两个子节点中的较大者交换来恢复堆  

理解了以上，才接着可以理解插入元素delete方法和删除最大元素方法delMax()  
insert():将新元素加入到数组的某尾，增加堆的大小并让这个新元素上浮到合适的位置  
delMax():从数组顶端删除最大元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置
