#字符串排序  
##准备活动
键索引计数法(按组号来排序)  
数组a[]中的每个元素都保存了一个名字和一个组号，在0到R-1之间  
分为四个步骤  
(1)频率统计  
使用int数组count[]计算每个键出现的频率，数组元素使用它的键访问count[]中相应元素并将其加1。  
(2)将频率转换成索引  
使用count[]来计算每个键在排序结果中的起始索引位置 ，思路：任意给定的键的起始索引均为所有较小的键所对应的出现频率之和。  
(3)数据分类  
将所有元素移动到一个辅助数组aux[]中以进行排序，元素在aux[]中的位置由它的键(组别)对应的count[]值决定，在移动之后将count[]中对应的元素的值加一。  
(4)回写  
最后一步就是将排序的结果复制到原数组中。  

特点：对小整数键排序非常有效，是理解更复杂的字符串排序的第一步。
```
            int N = a.length;
            String[] aux = new String[N];
			int[] count = new int[R+1];  //计算出现频率 
			for(int i=0;i < N; i++)
				count[a[i].key()+1]++;
			
			for(int r=0; r < R; r++)   //将频率转换为索引
				count[r+1] += count[r];
			
			for(int i = 0; i < N; i++) //将元素分类
				aux[count[a[i].key()]++] = a[i];
		
			for(int i = 0; i < N; i++)  //回写
				a[i] = aux[i];
```

##低位优先的字符串排序  
思路：从右向左以每个位置的字符作为键，用键索引计数法将字符串排序w遍(w为每个字符串的长度)  

核心：第i位键是有序的，那么把第i-1排序，那么依旧是有序的。依赖于键索引计数法的实现是稳定的。  

要求每个字符串的长度需要相同，当然可以改进，长度不同也没关系。  
性能：总运行时间与WN成正比(线性时间)  
W:字符串长度 &nbsp;&nbsp;&nbsp; N:字符串个数
