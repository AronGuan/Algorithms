#Boyer-Moore字符串查找算法  
思路：当可以在文本字符串中回退时，可以从右向左扫描模式字符串并将它和文本匹配。  

首先:使用数组right[]记录字母表中的每个字符在模式中出现的最靠右的地方(如果字符在模式中不存在则表示为-1)。这个值揭示了如果该字符出现在文本中且在查找时造成了一次匹配失败，应该向右跳跃多远。  

然后:用一个索引i在文本中从左向右移动，用另一个索引j在模式中从右向左移动。内循环会检查正文和模式字符串在位置i是否一致。如果从M-1到0的所有j,txt.charAt(i+j)都和pat.charAt(j)相等，那么就找到了一个匹配。否则匹配失败。  
构造  
```
right = new int[R];
		for(int c = 0;c < R;c++){
			right[c] = -1; //不包含在模式字符串中的字符的值为-1
		}
		for(int j = 0;j < M;j++){  //包含在模式字符串中的字符的值为
			right[pat.charAt(j)] = j;  //它在其中出现的最右位置
		}	
```


规则  
1. 如果造成匹配失败的字符不包含在模式字符串中，将模式字符串向右移动j+1个位置(即将i增加j+1)。小于这个偏移量只可能使该字符与模式中的某个字符重叠。  
2. 如果造成匹配失败的字符包含在模式字符串中，那就可以使用right[[数组来将模式字符串和文本对齐，使得该字符和它在模式字符串中出现的最右位置相匹配。和刚才一样，小于这个偏移量只可能使该字符和模式中的与它无法匹配的字符(比它出现的最右位置)重叠  
3. 如果这种方式无法增大i,那就直接将i加1来保证模式字符串至少向右移动了一个位置。  

```
for(int i = 0; i <=N-M;i += skip){
			//模式字符串和文本在位置i匹配吗?
			skip = 0;
			for(int j = M-1;j >=0; j--){
				if(pat.charAt(j) != txt.charAt(i+j)){
					//字符不在模式中，就变成j+1,在字符中，就使得该字符和它在模式字符串中出现的最右位置相匹配。
					skip = j - right[txt.charAt(i+j)]; 
					if(skip < 1) skip = 1;
					break;
				}
			}
			if(skip == 0) return i;    //找到匹配
		}
```